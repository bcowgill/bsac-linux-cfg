#!/usr/bin/perl
# Generated by ChatGPT 5
use strict;
use warnings;
use utf8;
use open qw(:std :utf8);
use English qw(-no_match_vars); # https://metacpan.org/pod/perlvar for reference
use File::Path qw(make_path);
use File::Basename;
use Getopt::Long;
use Pod::Usage;
use English;

my $ERR = "❌";   # red error cross

our $DEBUG = $ENV{DEBUG} || 0;

#------------------------------------------------------------
# Comment style mapping by extension
#------------------------------------------------------------
sub comment_style {
    my ($file) = @_;
    return '#'      if $file =~ /\.(pl|pm|sh|bash|py|rb|yaml|yml)$/i;
    return '//'     if $file =~ /\.(js|ts|jsx|tsx|c|cpp|cc|cxx|h|hpp|java|cs|go|rs|kt)$/i;
    return '/*'     if $file =~ /\.(css|less|sass|scss|pcss)$/i;
    return '<!--'   if $file =~ /\.(html?|xml|xhtml)$/i;
    return '--'     if $file =~ /\.(sql|lua)$/i;
    return '%'      if $file =~ /\.(m)$/i;       # MATLAB / Octave
    return ';'      if $file =~ /\.(ini)$/i;     # INI / Makefiles
    return '{-'     if $file =~ /\.(hs)$/i;      # Haskell block comment
    return undef;
}

#------------------------------------------------------------
# Make banner string for a file
#------------------------------------------------------------
sub make_banner {
    my ($file) = @_;
    my $style = comment_style($file)
      or die "$ERR Unknown source type (no comment style): $file\n";

    my $banner;
    if ($style eq '/*') {
        $banner = "/* === $file ";
    } elsif ($style eq '<!--') {
        $banner = "<!-- === $file ";
    } elsif ($style eq '--') {
        $banner = "-- === $file ";
    } elsif ($style eq '%') {
        $banner = "% === $file ";
    } elsif ($style eq ';') {
        $banner = "; === $file ";
    } elsif ($style eq '{-') {
        $banner = "{- === $file ";
    } else { # line comments: # or //
        $banner = "$style === $file ";
    }

    my $pad = 76 - length($banner);
    $pad = 10 if $pad < 10;
    $banner .= '=' x $pad;

    $banner .= " */"   if $style eq '/*';
    $banner .= " -->"  if $style eq '<!--';
    $banner .= " -}"   if $style eq '{-';

    return $banner;
}

#------------------------------------------------------------
# Validate file path
#------------------------------------------------------------
sub validate_path {
    my ($file) = @_;
    die "$ERR Invalid file path: $file cannot be relative or absolute path.\n"
      if $file =~ m{^\.\./} || $file =~ m{^\.\.} || $file =~ m{^/};
}

#------------------------------------------------------------
# Sort by depth then alphabetically
#------------------------------------------------------------
sub sort_files {
    return sort {
        scalar(() = $a =~ m{/}g) <=> scalar(() = $b =~ m{/}g)
        || $a cmp $b
    } @_;
}

#------------------------------------------------------------
# Detect binary file
#------------------------------------------------------------
sub is_text_file {
    my ($file) = @_;
    open my $fh, '<:raw', $file or die "$ERR Can't open source code file $file: $!\n";
    read $fh, my $buf, 1024;
    close $fh;
    return $buf !~ /\x00/;
}

#------------------------------------------------------------
# Combine mode
#------------------------------------------------------------
sub combine_files {
    my ($out_file, @files) = @_;
    @files = sort_files(@files);

    my $outfh;
    if ($out_file) {
        open $outfh, '>:encoding(UTF-8)', $out_file or die "$ERR Can't write code-tar file $out_file: $!\n";
    } else {
        $outfh = *STDOUT;
    }

    for my $file (@files) {
        validate_path($file);
        die "$ERR Missing file: $file\n" unless -f $file;
        die "$ERR Binary or unknown format: $file\n"
          unless is_text_file($file) && comment_style($file);

        open my $fh, '<:encoding(UTF-8)', $file or die "$ERR Can't read source code file $file: $!\n";
        my @lines = <$fh>;
        close $fh;

        my $banner = make_banner($file);

        # Remove existing banner lines at the top
        if (@lines && $lines[0] =~ /^\s*(?:\#|\/\/|\/\*|<!--|--|%|;|\{\-)\s*===/) {
            shift @lines;
        }

        # Preserve shebang if present
        if (@lines && $lines[0] =~ /^#!/) {
            my $shebang = shift @lines;
            print $outfh $shebang;
            print $outfh "$banner\n", @lines;
        } else {
            print $outfh "$banner\n", @lines;
        }
    }

    close $outfh if $out_file;
}

my $banner_re = qr{
    ^(?:\#|//|/\*|<!--|--|%|;|\{\-)
    \s*===\s+(.+?)\s+=+
}x;

sub write_code {
	my ($current_path, $raBuffer) = @_;
            if ($current_path) {
                validate_path($current_path);
                make_path(dirname($current_path));
                open my $out, '>:encoding(UTF-8)', $current_path
                  or die "$ERR Can't write source code file $current_path: $!\n";

                my $seen_banner = 0;
                for my $l (@$raBuffer) {
                    if ($l =~ $banner_re) {
                        next if $seen_banner++;
                    }
                    print $out $l;
                }
                close $out;
            }
}

#------------------------------------------------------------
# Split mode (with banner deduplication)
#------------------------------------------------------------
sub split_file {
    my ($file) = @_;
    open my $fh, '<:encoding(UTF-8)', $file or die "$ERR Can't read code-tar file $file: $!\n";
    my @lines = <$fh>;
    close $fh;

    my $current_path;
    my @buffer;

    for my $line (@lines) {
        debug("line: $line");
        if ($line =~ $banner_re) {
            debug("is banner!");
            # flush previous file
            write_code($current_path, \@buffer);
            $current_path = $1;
            @buffer = ($line);
        } else {
            debug("not banner.");
            push @buffer, $line;
        }
    }

    write_code($current_path, \@buffer);
}

#------------------------------------------------------------
# Check mode
#------------------------------------------------------------
sub check_file {
    my ($file) = @_;
    open my $fh, '<:encoding(UTF-8)', $file or die "$ERR check, Can't read code-tar file $file: $!\n";
    my @lines = <$fh>;
    close $fh;

    my %seen;
    my $banner_re = qr{
        ^(?:\#|//|/\*|<!--|--|%|;|\{\-)
        \s*===\s+(.+?)\s+=+
    }x;

    for my $line (@lines) {
        if ($line =~ $banner_re) {
            my $path = $1;
            validate_path($path);
            if ($seen{$path}++) {
                warn "$ERR DUPLICATE: $path\n";
            }
            if (-e $path) {
                print "EXISTS: $path\n";
            } else {
                print "NEW: $path\n";
            }
        }
    }
}

#------------------------------------------------------------
# Main
#------------------------------------------------------------
my $check;
my $help;
my $man;
my $out_file;
GetOptions(
    "check"    => \$check,
    "output=s" => \$out_file,
    "help|?"   => \$help,
    "man"      => \$man,
) or pod2usage(2);

if ($help)
{
	pod2usage(0);
}
if ($man)
{
	pod2usage(-verbose => 2, -exit => 0);
}

my @files;
if (@ARGV) {
    @files = @ARGV;
} else {
    @files = map { chomp; $_ } <STDIN>;
}

debug("check: @{[$check || '']}");
debug("files: " . join(", ", @files));

if ($check) {
    die "$ERR --check requires exactly one file\n" unless @files == 1;
    check_file($files[0]);
}
elsif (@files == 1) {
    split_file($files[0]);
}
else {
    if ($out_file) {
        die "$ERR --output requires at least two files to combine\n" unless @files > 1;
    }
    combine_files($out_file, @files);
}

sub debug
{
	my ( $msg, $level ) = @ARG;
	$level ||= 1;
	my $message;

##	print "debug @{[substr($msg,0,10)]} debug: $DEBUG level: $level\n";
	if ( $DEBUG >= $level )
	{
		$message = tab($msg) . "\n";
		print $message
	}
	return $message
} # debug()

# make tabs 3 spaces
sub tab
{
	my ($message) = @ARG;
	my $THREE_SPACES = ' ' x 3;
	$message =~ s{\t}{$THREE_SPACES}xmsg;
	return $message;
} # tab()

__END__

=head1 NAME

tar-code.pl - Combine and split source code files with standard comment banners

=head1 SYNOPSIS

tar-code.pl [options] file...

 Options:
   --check         Check banners in a combined file
   --output FILE   Write combined output to FILE instead of STDOUT
   --help, -?      Brief help message
   --man           Full documentation

=head1 DESCRIPTION

This script can combine multiple source code files into a single file
with a standard comment banner separating each one, or split a single
combined file back into the original files.

If multiple files are given, they are combined (sorted by subdirectory
depth then alphabetically) and written to STDOUT or the file specified
with C<--output>.

If a single file is given, it is split back into the original files,
creating subdirectories as needed.

If C<--check> is specified with a single file, the script scans for
standard banners and reports whether each file exists, will be created,
or appears multiple times.

Supports additional comment styles: %, ;, {-} for MATLAB, INI, Haskell, and Lua.

=cut

__DATA__
Here is the prompt given to ChatGPT to generate this script:

I need a perl script tar-code.pl which can combine multiple source code files into one single file with a standard comment banner separating each one.
The script should also be able to split a single file with these banners back into separate files again.

If a single file name is given to the script on the command line or from standard input then it will split that single file into multiple files.
If multiple file names are given on the command line or from standard input (one file name per line) it will combine all those source code files into one printed on standard output.

The format of the comment banner is appropriate to the programming language of the source code file.

For example:
for a perl, or other shell like file:
#!/usr/bin/perl
#=== path/to/source.pl ================================

for a javascript, typescript, jsx, tsx, or c++ source file:
// === path/to/source.js ================================

for html or xml:
<!-- === path/to.source.html ====================================== -->

for a css, less, sass or css modules file or other source code which does not have c++ style line commenting format:
/* === path/to/source.css =============================== */

The banner line will always start with three equals signs '===' after the relevant line comment character, followed by the path to the file and followed by at least 10 equal signs or out to column 76.

If the file already has a standard comment banner in it when read, only a single comment banner will be output. If there is no standard comment banner in the file when read, one will be added when output.

If a file is a script with a shebang line it should be preserved before the standard comment banner when being output.

When combining multiple files into one, the file names are sorted by sub directory depth then alphabetically so that the deepest source code files are added to the file first, followed by files above them.

When splitting a single file back into separate files the standard comment banner will remain in the output file.

When splitting a file back into multiple files any missing sub-directories will be created so that the file itself can be created.

If the --check parameter is given on the command line along with only a single file name it will scan the file for the standard comment banners and print to standard output:
NEW: path/to/file.js
or
EXISTS: path/to/file.js
depending on whether the source file already exists or will be created new.  In this case the file itself will not actually be created or written to.
During the --check mode if different standard comment banners refer to the same file name then DUPLICATE: path/to/file.js will be printed on standard error output in addition to the NEW or EXISTS message on standard output.

The script should handle all modern programming languages, web based languages and style sheets as well as markup languages like c, c++, java, python, shell, perl, python, html, xml, css and common file extension variants use for these file formats.

The script should also be able to handle known source code file extensions which contain unicode characters within strings and comments, like check marks, crosses and other emoji's

Error conditions:

Relative file names going to the parent directory ../ or absolute file names beginning with / are not allowed and will cause the script to die printing the invalid file name.  This applies only to the multiple file names on the command line, standard input or found in the comment banners of a file to split.  If supplying a single file name to split that can be relative or absolute with no error.

When combining files, if a file does not exist the script will die with an error message indicating the missing file.

If one of the multiple files to combine is not source code with a known commenting format, or is a binary file the script will die printing the name of the file.

Every error message line should be prefixed with a red error cross unicode character.

Also, ChatGPT asked to add:

Would you like me to also add **detection of existing banners inside split mode** (to ensure they’re never duplicated in the reconstructed files), or should the banner always be kept exactly as-is when splitting?

Would you like me to also add a `--output <file>` option for **combine mode**, so you don’t have to redirect with `>` manually?

yes, and add options called --help, --man or -? which prints out user help information for using the script and then exits.  Don't show the changes, just give me a script that I can run.

Then I asked:

Are there any other line or block commenting formats that are commonly used in programmig languages or configuration files that were missed?

... do you want me to update your script...

yes, please, I also noticed a few bugs.  1. SQL files should use -- comment banner, not a c++ style // comment.  2. When combining files that already have banners in them, the combined file has duplicated banners which only differ by the number of = signs in them.  There should only be one banner shown for each file in the combined file.  Also, pcss is a common file extension used for post-css processed files. Please add that file extension
